---
title: "Sistemas de información geográfica. TP2: Geoprocesos con datos vectoriales (continuación)"
author: Prof. Marcos May
email: mmmay@fahce.unlp.edu.ar
format:
  pdf:
    toc: true
    toc-title: Indice
    number-sections: false
    toc-depth: 3
    header-includes:
      - \titlehead{\flushright\includegraphics[width=0.4\textwidth]{../../images/Logo-fahce-unlp-negro.png}}
editor_options: 
  chunk_output_type: inline
---

## Objetivos

Este trabajo se propone introducir herramientas de análisis geoespacial con R aplicadas a una problemática educativa territorial: **la accesibilidad a escuelas secundarias** y las condiciones socioeducativas del entorno.

El ejercicio se desarrolla en el partido de **La Plata**, y se trabajará exclusivamente con **datos geográficos vectoriales**, es decir, información representada como **puntos** (escuelas) y **polígonos** (radios censales), incorporando atributos provenientes del **Censo 2022**.

------------------------------------------------------------------------

## Carga y preparación de datos censales

```{r}
#| label: setup
#| warning: false
#| message: false
#| echo: true
library(tidyverse)   # Manipulación de datos  
library(sf)          # Datos espaciales  
library(mapview)     # Mapas interactivos  
library(units)       # Manejo de distancias (metros/km)  
library(nngeo)       # Para cálculos de distancia más cercana  
library(here)        # Para manejar el path
library(janitor)     # Para limpieza de datos
library(ggspatial)   # Visualización
library(maptiles)    # Visualización
library(prettymapr)  # Visualización
```

::: callout-important
##### ¿Por qué trabajar con datos del Censo?

Los **datos censales** constituyen una de las fuentes más potentes y exhaustivas para el análisis territorial y social en Argentina. Su integración con herramientas de **Sistemas de Información Geográfica (SIG)** permite combinar variables sociodemográficas con coordenadas espaciales, abriendo un abanico de posibilidades para el análisis descriptivo, diagnóstico y toma de decisiones.

En contextos donde otras fuentes tienen baja cobertura o disponibilidad (como registros administrativos desactualizados, encuestas parciales o registros focales), el censo aporta:

-   **Cobertura universal**: incluye a todas las personas, hogares y viviendas del país.
-   **Desagregación geográfica**: permite trabajar con unidades mínimas como radios censales, fundamentales para el análisis intraurbano o de desigualdades territoriales.
-   **Variables clave para ciencias sociales**: nivel educativo, hábitat, acceso a servicios, características de los hogares, actividad económica, entre otras.
:::

```{r}
radios <- 
  st_read(here('data/raw/censo/radios_censales/Radios 2022 v2025-1.shp'))
```

Con `st_crs()` nos fijamos el sistema de coordenadas del geodataframe cargado:

```{r}
st_crs(radios)
```

Este sistema de coordenadas es proyectado y su uso está bastante extendido en plataformas como Google Maps, OSM, entre otras. <https://epsg.io/3857>

Exploramos el dataframe con `glimpse()`:

```{r}
radios |> st_drop_geometry() |> glimpse()

```

Utilizamos `clean_names()` para limpiar los nombres de las columnas y pasarlas a minúscula.

```{r}
radios <- 
  radios |> clean_names()
```

::: callout-warning
#### Enlaces útiles

Geometrías Partidos Bs As. DPE <https://www.mapas.estadistica.ec.gba.gov.ar/portal/apps/sites/#/mapas-estadisticos/pages/descargas-shapes>

Base REDATAM <https://redatam.indec.gob.ar/binarg/RpWebEngine.exe/Portal?BASE=CPV2022&lang=ESP>

Municipio, localidad y departamento: tres conceptos que suelen confundirse. INDEC <http://municipios.unq.edu.ar/modules/mislibros/archivos/municipium03.pdf>

Capas IGN <https://www.ign.gob.ar/NuestrasActividades/InformacionGeoespacial/CapasSIG>
:::

## Visualización en `ggplot()` con `geom_sf()`

`mapview()` es muy útil para explorar datos espaciales porque es interactivo: podemos movernos, hacer zoom y ver detalles.\
Pero, cuando trabajamos con capas muy grandes, como todos los radios censales de la Provincia de Buenos Aires puede volverse lento y pesado. Además no siempre es cómodo integrarlo en un informe o presentación.

En esos casos, `ggplot()` con `geom_sf()` es una gran alternativa.\
Nos permite crear mapas estáticos que cargan rápido, se ven bien desde el primer momento y son totalmente personalizables. Al estar dentro del **tidyverse**, se integra de forma natural con `dplyr`, `tidyr` y el resto de herramientas que usamos para procesar datos, sin salir del mismo flujo de trabajo.

```{r}
radios |> 
  filter(prov == '06') |> 
  ggplot() +
  geom_sf(fill = NA, 
          color = "gray40", size = 0.1) +
  labs(title = "Radios Censales - PBA",
       subtitle = "Fuente: INDEC",
       caption = "Cod. Provincia 06") +
  #theme_minimal()
  theme(
    panel.background = element_blank(),  
    plot.background = element_blank(),   
    panel.grid = element_blank(),        
    axis.text = element_blank(),         
    axis.title = element_blank(),
    axis.ticks = element_blank()
  )

```

Ahora vamos a graficar el partido (departamento) de La Plata. El código es 441 (ver documentación censo 2022, 'Códigos Geográficos').

```{r}
#| eval: false
#| include: false

radios <- 
  radios |> mutate(depto_ = paste0(prov,depto) )

lp <- 
  radios |> filter(depto_ == '06441')
  #radios |> filter(depto_ == '14182')
#mapview(lp)
```

```{r}
#| echo: true
lp <- 
  radios |> 
  filter(depto == '441')
```

```{r}
ggplot() +
  geom_sf(data = lp, 
          fill = "lightblue", 
          color = "grey",
          size = 0.1) +
  theme_minimal() +
  labs(title = "Radios Censales - La Plata")
```

El radio 064417101 es la isla martin garcía, lo podemos ver con `mapview()`.

```{r}
#| echo: true
#| eval: false
mapview(lp,label = 'cod_2022')
```

```{r}
lp <- 
  lp |> 
  filter(cod_2022 != '064417101' )
```

```{r}
ggplot() +
  geom_sf(data = lp, 
          fill = NA, 
          color = "lightgrey", 
          size = 0.3) +
  theme_minimal() +
  labs(title = "Radios Censales - La Plata")+
  theme(panel.grid = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank())
```

::: callout-warning
Al trabajar con las geometrías del censo recordá que en la mayoría de las provincias no hay correspondencia entre los gobiernos locales (Municipios) y los departamentos (partidos en PBA, comunas en CABA). Ver ([INDEC, 1999](https://biblioteca.indec.gob.ar/bases/minde/132_3.pdf%20)), (Vapñarsky, 2004). Podés descargar los metadatos del censo (incluídas las unidades geoestadísticas y los códigos desde [acá](https://www.indec.gob.ar/ftp/cuadros/poblacion/metadatos_censo2022_redatam.zip)).
:::

## Clima Educativo del Hogar (REDATAM)

Hasta acá trabajamos con las **geometrías de los radios censales** del Censo 2022 que definen las unidades territoriales básicas para el análisis espacial. Sin embargo la información detallada de cada radio, como características socioeconómicas o educativas de los hogares, no está incluida directamente en estas geometrías.

Para acceder a esos datos es necesario utilizar la plataforma **REDATAM** del INDEC que permite consultar, filtrar y descargar microdatos censales. Por ejemplo una variable que podemos obtener es el **clima educativo del hogar (EDUHOG)**, que representa el promedio de años de estudio alcanzados por los miembros mayores de 18 años en cada hogar. Esta variable tiene categorías que van desde “Muy bajo” hasta “Muy alto”, según el nivel educativo promedio. El paso siguiente consiste en integrar (hacer un join por código geográfico) la información descargada desde REDATAM con las geometrías de los radios censales para poder realizar análisis territoriales más completos y visualizaciones geográficas enriquecidas.

(ver documentación censo 2022, 'Definiciones y conceptos. Definiciones de la base de datos').

| Código | Rótulo         |
|--------|----------------|
| 1      | Muy bajo       |
| 2      | Bajo           |
| 3      | Medio          |
| 4      | Alto           |
| 5      | Muy alto       |
| 9      | No corresponde |

En este caso realizamos una consulta en **REDATAM** para obtener la información de **clima educativo del hogar (EDUHOG)** correspondiente a los radios censales del **Partido de La Plata**.

```{r}
library(readxl)
clima <- 
  read_excel(here("data/processed/redatam_censo/lp_clima_educativo.xlsX"), 
    range = "b12:h1061")

clima <- 
  clean_names(clima)
head(clima)
```

Si bien **clima educativo del hogar (EDUHOG)** es una variable categórica ordinal en este análisis calculamos el promedio de sus valores numéricos asignados para los hogares dentro de cada radio censal.

Este promedio permite obtener una medida resumida del nivel educativo predominante en cada radio, facilitando su comparación y representación espacial, a pesar de la naturaleza ordinal de la variable.

```{r}
clima <- 
  clima |>
  mutate(total_hogares = muy_bajo + bajo + medio + alto +  muy_alto,
    promedio_eduhog = (
      1 * muy_bajo +
      2 * bajo +
      3 * medio +
      4 * alto +
      5 * muy_alto
    ) / (total_hogares)
  )

summary(clima$promedio_eduhog)
```

Para realizar la unión (join) entre las geometrías de los radios censales y la información de clima educativo, es necesario que las variables clave para el cruce tengan el mismo tipo de dato.

En el objeto `lp`, la variable que identifica cada radio censal es `cod_2022` y está almacenada como **carácter (character)**.

En cambio, en el objeto `clima`, el código del radio censal se encuentra en la variable `codigo` y es de tipo **numérico (numeric)**.

Para asegurar la compatibilidad y evitar problemas en la unión, convertimos la variable `cod_2022` en `lp` a numérica utilizando `as.double()`.

Luego realizamos el join por esta variable común para incorporar la información de clima educativo a las geometrías de los radios censales.

```{r}
lp <- 
  lp |> 
  mutate(codigo = as.double(cod_2022 )) |> 
  left_join(clima, by = 'codigo')
```

```{r}
ggplot() +
  geom_sf(data = lp, 
          aes(fill = promedio_eduhog)) +
  theme_minimal() +
  labs(title = "Clima educativo - La Plata")

```

El mapa que generamos muestra claramente la distribución del clima educativo por radio censal. Sin embargo, para facilitar una mejor interpretación espacial y contextualizar estos datos, es útil agregar un fondo de mapa base que muestre calles, ríos u otros elementos geográficos reconocibles. Este fondo se conoce como un **tile**, que consiste en una capa compuesta por imágenes cuadriculadas que representan detalles geográficos. Al superponer este tile debajo de los polígonos, el mapa gana en claridad y comprensión espacial.

En `ggplot2`, usando el paquete **ggspatial**, podemos agregar este fondo fácilmente con la función `annotation_map_tile()`. Esta función descarga automáticamente los tiles desde proveedores de mapas en línea (por defecto, OpenStreetMap), y los superpone en el gráfico. Podemos modificar parámetros como:

-   La transparencia del tile con el argumento `alpha` para evitar que el fondo opaque la información principal.

-   La fuente o proveedor del tile, seleccionando entre diferentes opciones disponibles en `ggspatial` para adaptar el estilo del mapa base a nuestras necesidades.

-   Además, es común incluir elementos como la barra de escala y la flecha indicadora del norte para facilitar la lectura y orientación del mapa. Estas se agregan con las funciones `annotation_scale()` y `annotation_north_arrow()` respectivamente, donde también es posible ajustar su ubicación y estilo.

```{r, fig.align='center', fig.width=7, fig.height=6}
#| message: false
#| warning: false
grafico_clima <-
  ggplot() +
  geom_sf(
    data = lp, 
    aes(fill = promedio_eduhog ), 
    color = NA,  #sin bordes
    size = 0 #sin grosor
  ) +
  scale_fill_gradient(
    high = "#FFCCCB",  
    low = "#8B0000", 
    name = "Promedio del clima educativo del hogar") +
  theme_minimal() +
  labs(
    title = "Clima educativo - La Plata",
    subtitle = "Radios con menor clima educativo en rojo intenso",
    caption = "Fuente: Elaboración propia en base a INDEC 2022"
  ) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    plot.subtitle = element_text(hjust = 0.5, color = "gray30"),
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 10), 
    panel.grid = element_blank(),
    axis.text = element_blank()
  )

grafico_clima+
    annotation_map_tile(alpha = 0.2)+
  annotation_scale(location = "bl", width_hint = 0.5) +
  annotation_north_arrow(location = "tr", which_north = "true",
                         style = north_arrow_fancy_orienteering)

```

```{r}
#| eval: false
#| include: false
lp_3857 <- st_transform(lp, 3857)
library(maptiles)

bg <- get_tiles(lp_3857, provider = "OpenTopoMap", crop = TRUE)

grafico_clima+
layer_spatial(bg, alpha = 0.3) 

```

## Accesibilidad escuelas secundarias

Cargamos el dataset de escuelas georreferenciadas trabajado en el TP anterior y filtramos los establecimientos situados dentro del partido de La Plata. A partir de esta información, vamos a calcular la accesibilidad a las escuelas secundarias para cada radio censal. En este contexto, la accesibilidad hace referencia a la distancia más corta (medida en línea recta, o distancia euclidiana) entre el centroide de cada radio y el establecimiento educativo más cercano. Este indicador permite identificar áreas con mejor o peor cobertura territorial, lo que resulta útil para el análisis de desigualdades en la distribución espacial de los servicios educativos.

```{r}
escuelas <-
  st_read(here('data/raw/educacion/establecimientos-educativos-28072025.geojson'))
escuelas <- 
  escuelas |> filter(municipio_nombre == 'La Plata')

```

Queremos hacerlo para las escuelas secundarias:

```{r}
escuelas |> 
  st_drop_geometry() |> 
  count(nivel)
```

```{r}
secu <- 
  escuelas |> 
  filter(nivel == 'Nivel Secundario')
```

A continuación, calculamos los centroides para cada radio censal utilizando la función `st_centroid()`. El centroide es un punto que representa la posición “central” de una geometría, calculado a partir de su forma y extensión. En términos simples, puede pensarse como el “centro de gravedad” del polígono que define el radio censal. Si bien no siempre coincide con un punto físicamente accesible (por ejemplo, podría caer en un área sin construcciones), resulta muy útil para realizar cálculos espaciales, como medir distancias a otros puntos de interés.

```{r}
#| message: false
#| warning: false
centroides <- 
  st_centroid(lp)
```

```{r, fig.align='center', fig.width=7, fig.height=6}
ggplot(lp) +
  geom_sf() +
  geom_sf(data = centroides, size = 0.01, color = "tomato") +
  theme_minimal() +
  labs(title = "Radios censales y sus centroides - Partido de La Plata")
```

Hasta acá los datos espaciales que cargamos están en el sistema de referencia EPSG:3857, conocido como **Web Mercator** que es muy usado para mapas web pero no es óptimo para cálculos precisos de distancia debido a sus distorsiones especialmente en zonas alejadas del ecuador.

Por ello para realizar mediciones espaciales más exactas —como calcular distancias euclidianas entre centroides y escuelas— transformamos los objetos (`lp`, `centroides`, `secu`) al sistema proyectado **EPSG:5347** (POSGAR 2007 / Argentina 5), que está diseñado para la Argentina y usa metros como unidad.

Esta transformación garantiza que las distancias calculadas sean más precisas y consistentes con la realidad territorial además de asegurar que todas las capas se encuentren en el mismo sistema espacial para un correcto análisis y visualización.

```{r}
lp <- st_transform(lp, 5347)
centroides <- st_transform(centroides, 5347)
secu <- st_transform(secu, 5347)
```

Guardamos los centroides generados en nuestra carpeta de datos procesados:

```{r}
save(centroides, 
     file = here('data/processed/lp_centroides_radios.Rda'))
```

Para calcular la accesibilidad a las escuelas secundarias desde cada radio censal, utilizamos la función `st_nn()` del paquete **nngeo**. Esta función nos permite encontrar para cada centroide del radio censal la escuela más cercana (`k = 1`) y obtener la distancia a esa escuela.

El resultado es una lista donde:

-   `nn[[1]]` contiene los índices de las escuelas más cercanas,

-   `nn[[2]]` contiene las distancias correspondientes.

Luego, extraemos las distancias y las asignamos directamente a una nueva variable `dist_sec` dentro del objeto `lp`.

```{r}
#| label: calculo-distancias
#| eval: false
#| fig-cap: Cálculo de distancias
#| include: false
# Distancia a secundaria más cercana (en m)
lp$dist_sec <- 
  st_distance(centroides, secu) |>
  apply(1, min) 
```

```{r}
#| message: false
nn <-
  st_nn(centroides,
        secu,
        k = 1,
        returnDist = TRUE)
```

```{r}
lp$dist_sec <-  unlist(nn[['dist']])
```

```{r,fig.align='center', fig.width=7, fig.height=6}
ggplot() +
  geom_sf(
    data = lp,
    aes(fill = dist_sec),
    color = NA,
    size = 0) +
  scale_fill_gradient(
    low = "#FFCCCB",  
    high = "#8B0000",
    name = "Distancia en metros") +
  #scale_fill_viridis_c(#option = "C",
  #                     name = "Distancia en metros",
  #                     alpha =  0.3)+
  theme_minimal() +
  labs(
    title = "Accesibilidad escuelas secundarias - La Plata",
    subtitle = "Radios censales con mayor distancia en rojo intenso",
    caption = "Fuente: Elaboración propia en base a INDEC 2022 y DGCyE 2024"
  ) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    plot.subtitle = element_text(hjust = 0.5, color = "gray30"),
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 10)  )
```

## Índice sintético de accesibilidad y clima educativo

Para generar un índice sintético que combine la accesibilidad educativa y el clima educativo del hogar, primero normalizamos ambas variables para ponerlas en una misma escala de 0 a 1 y poder combinarlas. Normalizar es transformar los datos para que sus valores queden entre 0 y 1, facilitando la comparación y combinación de variables con unidades o rangos diferentes.

La variable de distancia (`dist_sec`) mide qué tan lejos está un radio censal de la escuela más cercana; valores altos indican peor accesibilidad. Sin embargo, al combinarla con el clima educativo (donde valores más altos son mejores), queremos que una mejor accesibilidad (menor distancia) se traduzca en un valor más alto en la escala normalizada.

Para lograr esto, invertimos la distancia multiplicándola por -1 antes de normalizar con `rescale()`. Así, las distancias cortas se convierten en valores cercanos a 1 y las largas en valores cercanos a 0.

Luego, normalizamos el promedio del clima educativo (`promedio_eduhog`) para que también esté entre 0 y 1.

Finalmente, calculamos el índice como la media ponderada de ambos valores normalizados, integrando accesibilidad y clima educativo en un solo indicador.

```{r}
#| eval: false
#| include: false
poblacion <- 
  read_excel(here("data/processed/redatam_censo/lp_edad_grandes_grupos.xlsX"),
             skip = 11,
             n_max = 1048)
```

```{r}
#| eval: false
#| include: false
lp <- 
  lp |> 
  left_join(poblacion[,c('Total','Código')],
            by = c('codigo' = 'Código'))
```

```{r}
#| message: false
library(scales)

lp$dist_norm <- rescale(-lp$dist_sec)
lp$prom_norm <- rescale(lp$promedio_eduhog )

lp$indice <-  lp$dist_norm * 0.5 + lp$prom_norm *0.5

```

```{r}
save(lp, file = here('data/processed/lp.Rda'))
save(secu, file = here('data/processed/secundarias_lp.Rda'))

```

```{r fig.align='center', fig.height=6, fig.width=7}
#| message: false
grafico_indice <- 
  ggplot() +
  geom_sf(
    data = lp, 
    aes(fill = indice), 
    color = NA,  
    size = 0  
  ) +
  scale_fill_gradient(
    high = "#FFCCCB",  
    low = "#8B0000", 
    name = "Indice educativo") +
  theme_minimal() +
  labs(
    title = "Índice accesibilidad y clima educativo",
    subtitle = "Radios con peor situación en rojo intenso",
    caption = "Fuente: Elaboración propia en base a INDEC 2022; DGCyE 2024; OpenStreetMap 2025"
  ) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    plot.subtitle = element_text(hjust = 0.5, color = "gray30"),
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 10),
    plot.caption = element_text(size = 5)
  )

    grafico_indice+
      annotation_map_tile(data = lp, alpha = 0.3)
```

```{r}
#| eval: false
#| include: false
st_crs(lp)  # debería ser 4326

# Paso 2: Reproyectar a EPSG:3857 (Google Web Mercator, necesario para tiles)
lp_3857 <- st_transform(lp, 3857)

library(maptiles)
# Paso 3: Obtener fondo satelital (tile) desde Esri
bg <- get_tiles(lp_3857, provider = "Esri.WorldImagery", crop = TRUE)

grafico_clima+
layer_spatial(bg, alpha = 0.3) 
```

```{r}
#| eval: false
#| include: false
#descargar y probar con otros datasets: salud, datos #abiertos pba.
#
#universidad..avisos inmobiliarios; ver ideba
#
#levantar un csv, aca probar con uno de inmo, hacer una #limpieza con rinmoscrap o jpoin con poligonos da arba, #censo etc.
#
#tp2
#
#calcular el clima educativo del área de influencia (buffer) #de cada escuela.
#
#escuelas secundarias:
#
#buffer 500 metros
#
#intersección con radios censales: st_filter y st_intersect. #criterios de corte basados en la poporción del área #intersectada sobre el total del radio
#
#tp3
#
#promedio de distancia manhattan de 4 puntos elegidos al #azar dentro del radio
```

```{r}
#| eval: false
#| include: false
#library(mapboxapi)

#install.packages('tidygeocoder')
#library(tidygeocoder)
#install.packages('osrm')
#library(osrm)




```

```{r}
#| eval: false
#| include: false
num_puntos <- 5

# Crear una lista vacía para almacenar los puntos
lista_puntos_aleatorios <- vector("list", length = nrow(lp))

# Iterar sobre cada polígono de lp
for (i in seq_len(nrow(lp))) {
  tryCatch({
    # Acceder a la geometría del polígono i
    geometria <- st_geometry(lp)[i]
    
    # Verificar si el polígono no está vacío
    if (!st_is_empty(geometria)) {
      lista_puntos_aleatorios[[i]] <- st_sample(geometria, size = num_puntos, type = "random")
    } else {
      lista_puntos_aleatorios[[i]] <- NULL  # Si es un polígono vacío
    }
  }, error = function(e) {
    cat("Error en el polígono", i, "\n")
  })
}




names(lista_puntos_aleatorios) <- lp$cod_2022
save(lista_puntos_aleatorios,
     file =  here('tp3/lista_puntos_aleatorios.Rda'))
save(lp, file = here('lp.Rda'))

#mapview(lista_puntos_aleatorios[[6]])



```
