---
title: "Sistemas de información geográfica. TP1"
format:
  pdf:
    toc: true
    toc-title: Indice
    number-sections: false
    toc-depth: 3
editor_options: 
  chunk_output_type: inline
---

------------------------------------------------------------------------

## Objetivos

Este trabajo se propone presentar cómo son tratados los **objetos espaciales vectoriales en R**, principalmente a través del uso de la librería `{sf}` dentro del ecosistema `{tidyverse}`. Se abordan conceptos fundamentales sobre el formato, la manipulación y la visualización de datos vectoriales, y se exploran algunas de las **operaciones básicas de geoprocesamiento**, como la generación de buffers, la unión espacial y los filtros por atributos. Además, se muestra cómo utilizar distintas herramientas para la visualización tanto dinámica (`mapview()`) como estática (`ggplot2 + geom_sf()`), aplicadas a datos reales provenientes de fuentes públicas.

#### Objetivo general

**Manipular, visualizar y analizar datos geográficos vectoriales en R, utilizando herramientas del paquete `{sf}` y del ecosistema `{tidyverse}`.**

#### Objetivos específicos

-   Comprender el formato y la estructura de los objetos vectoriales en

    R.  

-   Abrir y trabajar con diferentes formatos de archivos geoespaciales (`.csv`, `.kml`, `.shp`, `.gpkg`).

-   Explorar y visualizar datos espaciales mediante `mapview()` y `geom_sf()`.

-   Aplicar filtros por atributos y realizar uniones espaciales.

-   Revisar y utilizar fuentes de datos abiertas disponibles (Gobierno de la Provincia de Buenos Aires, INDEC, OpenStreetMap, RENABAP, entre otras).

------------------------------------------------------------------------

## Tipo de Vectores. Carga y exploración de datos

```{r setup, warning=FALSE, echo=FALSE, message=FALSE}
library(tidyverse)   # Manipulación de datos  
library(sf)          # Datos espaciales  
library(mapview)     # Mapas interactivos  
library(here)        # Para manejar el path
library(janitor)     # Para limpieza de datos
```

En los Sistemas de Información Geográfica (SIG), los datos vectoriales se utilizan para representar entidades geográficas mediante tres tipos básicos de geometrías:

-   **Puntos:** representan ubicaciones precisas, como edificios, centros de salud o antenas.

-   **Líneas:** representan elementos lineales, como caminos, ríos o redes de transporte.

-   **Polígonos:** representan superficies delimitadas, como barrios, parcelas o áreas censales.

Cuando se cargan en R mediante la librería {sf}, estos datos vectoriales se transforman en data frames espaciales, también conocidos como geodataframes u objetos sf. Al igual que un data.frame o un tibble, estos objetos tienen filas (una por cada entidad geográfica) y columnas (atributos descriptivos). Lo que los distingue es la inclusión de una columna especial llamada geometry, que almacena la información espacial (coordenadas de puntos, líneas o polígonos).

Este diseño permite trabajar de forma integrada con los datos alfanuméricos y espaciales. Por ejemplo, al aplicar funciones como print() o head() se visualiza tanto la tabla como un resumen de la geometría. Además, los objetos sf son plenamente compatibles con el ecosistema {tidyverse}, lo que permite usar funciones como filter(), mutate(), group_by() o select() sobre capas espaciales. Estas operaciones pueden luego complementarse con funciones específicas para análisis geográficos como st_join(), st_buffer(), st_intersection(), entre otras que se verán más adelante.

Una vez abiertos, los datos pueden explorarse visualmente de dos formas principales:

-   **Visualización interactiva con `mapview()`:** permite inspeccionar los datos de forma dinámica, hacer zoom, ver atributos al pasar el cursor y superponer capas. Esta herramienta es ideal para la etapa exploratoria, aunque **no puede visualizarse directamente en archivos PDF**. Se recomienda su uso durante el trabajo en RStudio o en informes generados en formato HTML, donde la interactividad es compatible.

-   **Visualización estática:**

    -   **Con `plot()` (R base):** ofrece una forma rápida y sencilla de visualizar objetos `sf`. Es útil para hacer inspecciones básicas de los datos espaciales, como revisar geometrías, identificar errores topológicos o visualizar atributos de forma individual. No requiere paquetes adicionales.

    -   **Con `ggplot2` y `geom_sf()`:** permite generar mapas reproducibles y de alta calidad, con mayor control sobre la estética, las escalas, los temas y la combinación con otros tipos de gráficos. Este enfoque es especialmente adecuado para informes formales, publicaciones científicas o presentaciones, y se desarrollará más adelante en el documento.

A continuación, se presentan ejemplos concretos de cada tipo de geometría (puntos, líneas y polígonos), utilizando fuentes de datos abiertas provistas por organismos oficiales (Gobierno de la Provincia de Buenos Aires, INDEC, RENABAP, OpenStreetMap, entre otros). Los datos provienen de distintos formatos geográficos (como .csv, .kml, .shp y .gpkg) y son abiertos en R mediante las funciones st_read() (cuando el archivo ya contiene geometría) o st_as_sf() (cuando la geometría se construye a partir de coordenadas). Se abordan algunas herramientas de exploración gráfica como plot() y mapview().

### Puntos

**Capa:** Establecimientos de Salud Públicos. **Fuente:** Ministerio de Salud de la Provincia de Buenos Aires. ( A través de Portal de Datos Abiertos de la Provincia de Buenos Aires). **Link:** <https://catalogo.datos.gba.gob.ar/dataset/establecimientos-salud/archivo/c52f9497-9eab-4ecd-a382-b4e4c6033a02> **Formato:** `.csv` (valores separados por comas)

El formato `.csv` (Comma-Separated Values) es un formato tabular ampliamente utilizado, aunque **no incluye información espacial directamente**. Para convertirlo en un objeto espacial, es necesario indicar manualmente qué columnas contienen las coordenadas (en este caso: `long` y `lat`). Para ello se utiliza `st_as_sf()` de la librería `{sf}`.

```{r}
salud<-
  read_delim(here("data/raw/salud/establecimientos_salud_publicos-2025.csv"), 
    delim = ";", escape_double = FALSE, trim_ws = TRUE)
```

```{r}
salud_sf <- 
  st_as_sf(salud,
           coords = c("long", "lat"),
           crs = 4326)
```

#### Visualización rápida con `plot()` (R base)

Una forma simple y directa de visualizar datos espaciales es utilizando la función `plot()` de R base, que es compatible con objetos `sf`. Esta función permite generar mapas estáticos sin necesidad de cargar paquetes adicionales de visualización.

Si usamos `plot()` directamente sobre el objeto `sf`, se generarán múltiples paneles, uno por cada variable del conjunto:

```{r}
plot(salud_sf)
```

Podemos seleccionar una sola columna (atributo) utilizando el nombre de la variable. Por ejemplo, si queremos graficar únicamente la variable 'Dep', usamos:

```{r}
plot(salud_sf[,'Dep'])
```

Esto mostrará un mapa donde las geometrías se colorean según los valores de la variable Dep.

También podemos filtrar por fila, es decir, seleccionar una sola entidad geográfica (por ejemplo, un solo punto, línea o polígono) y graficarla:

```{r}
plot(salud_sf[355,'Dep'])
```

En este caso se visualiza solo el punto ubicado en la posición 355 del dataframe. Este método cobra más relevancia cunado queremos explorar polígonos, por ejemplo para ver la forma de algún radio censal o barrio.

**Capa:** Establecimientos educativos. **Fuente:** DGCyE. (A través de Portal de Datos Abiertos de la Provincia de Buenos Aires). **Link:** <https://catalogo.datos.gba.gob.ar/dataset/establecimientos-educativos> **Formato:** `.geojson` (GeoJSON)

El **formato `.geojson`** es una extensión del formato JSON especialmente diseñado para representar información geoespacial. Es un formato **ligero, basado en texto plano**, ampliamente utilizado para intercambio de datos en la web y compatible con una gran variedad de plataformas y librerías.

A diferencia del `.csv`, los archivos `.geojson` **ya contienen información geométrica estructurada**, y pueden abrirse directamente como objetos `sf` usando `st_read()`, sin necesidad de especificar columnas de coordenadas.

```{r}
escuelas <-
  st_read(here("data/raw/educacion/establecimientos-educativos-09062025.geojson"))
```

### Líneas

**Capa:** Avenidas del partido de La Plata. **Fuente:** OpenStreetMap (OSM), descargado mediante API. **Formato:** .gpkg (GeoPackage).

El formato GeoPackage (.gpkg) es un estándar moderno y recomendado para trabajar con información geoespacial. A diferencia de archivos como .shp (que requieren múltiples archivos complementarios), un .gpkg almacena todos los datos en un único archivo, incluyendo geometría, atributos, proyecciones y múltiples capas.

```{r}
#| eval: false
#| include: false

# Los datos utilizados provienen de OpenStreetMap (OSM), un proyecto colaborativo
# que busca construir un mapa libre, abierto y editable del mundo. Al estilo de
# una “Wikipedia de los mapas”, cualquier persona puede contribuir agregando
# calles, edificios, escuelas o espacios públicos. Esto lo convierte en una fuente
# valiosa, especialmente en contextos donde los datos oficiales son escasos o
# difíciles de obtener.
#
# Una de sus ventajas clave es que OSM es gratuito, a diferencia de servicios como
# Google Maps que tienen restricciones de uso o cobran por volumen. Por eso, es
# muy utilizado en proyectos educativos, desarrollos de software libre,
# investigaciones y planificación urbana.
#
# Sin embargo, la cobertura y el nivel de detalle pueden variar según la región,
# ya que dependen del grado de participación de la comunidad local. En grandes
# ciudades o áreas con comunidades activas, la cartografía suele estar muy
# actualizada; en cambio, en zonas rurales o menos representadas, puede haber
# vacíos o menor precisión. Aun así, es una fuente confiable, abierta y revisada
# continuamente, con mecanismos para validar y corregir los datos aportados.
#
# En R, una de las formas más comunes de acceder a OSM es a través del paquete
# osmdata, que permite realizar consultas a la API y descargar datos vectoriales
# directamente como objetos sf. Ver catalogo: https://wiki.openstreetmap.org/wiki/Map_features
```

```{r}
#| eval: false
#| include: false
#| echo: false
avenidas <-
  st_read(here("data/raw/OSM/avenidas_osm.gpkg"))
```

### Polígonos

**Capa:** Radios censales 2022 **Fuente:** Repositorio Institucional CONICET (Rodríguez, Gonzalo Martín) **Link:** <https://ri.conicet.gov.ar/handle/11336/238198> **Formato:** .shp (Shapefile).

El formato Shapefile (.shp) es uno de los formatos vectoriales más antiguos y extendidos en los Sistemas de Información Geográfica. Fue desarrollado por ESRI y permite almacenar información geoespacial de puntos, líneas o polígonos, junto con sus atributos.

Un shapefile no es un único archivo, sino un conjunto de al menos tres archivos obligatorios, que deben estar en la misma carpeta para que la información sea leída correctamente:

-   .shp: contiene las geometrías (la representación espacial de los objetos).

-   .shx: contiene un índice de las geometrías, que permite un acceso más rápido.

-   .dbf: almacena los atributos (es una tabla en formato dBase, similar a una hoja de cálculo).

Además, pueden aparecer archivos adicionales:

-   .prj: contiene la información de proyección (sistema de coordenadas).

-   .cpg: indica la codificación de caracteres del archivo .dbf (útil para mostrar tildes y eñes).

-   .qpj: una variante moderna del .prj, usada por algunos programas como QGIS.

Para trabajar correctamente con un shapefile, es importante mantener juntos todos estos archivos. El archivo .shp por sí solo no es suficiente.

En este caso, se trata de la capa de radios censales publicada como insumo para el Censo Nacional 2022. Representa unidades geográficas en las que se organizan los operativos censales, y es una capa clave para análisis sociodemográficos.

```{r}
radios <- 
  st_read(here("data/raw/censo/radios_censales/Radios 2022 v2025-1.shp"))
```

```{r}
plot(radios[1,1])
```

::: callout-warning
Al trabajar con las geometrías del censo recordá que en la mayoría de las provincias no hay correspondencia entre los gobiernos locales (Municipios) y los departamentos (partidos en PBA, comunas en CABA). Ver (INDEC, 1999), (Vapñarsky, 2004). Podés descargar los metadatos del censo (inluídas las unidades geoestadísticas y los códigos desde [acá](https://www.indec.gob.ar/ftp/cuadros/poblacion/metadatos_censo2022_redatam.zip)).
:::

**Capa:** Barrios populares (RENABAP)\
**Fuente:** Registro Nacional de Barrios Populares (RENABAP), disponible en datos.gob.ar **Link:** <https://datos.gob.ar/dataset/habitat-registro-nacional-barrios-populares>\
**Formato:** `.gpkg` mal guardado (sin extensión)

Esta capa contiene los polígonos correspondientes a los **barrios relevados por el RENABAP**, que representan áreas urbanas informales reconocidas oficialmente por el Estado Nacional. Estos datos permiten identificar situaciones de vulnerabilidad habitacional y son clave en estudios urbanos, sociales y de accesibilidad.

El archivo provisto está en formato GeoPackage, pero fue **mal guardado sin extensión**, lo que genera una advertencia al intentar leerlo con `{sf}`. Aun así, `st_read()` logra interpretar correctamente el contenido si se especifica la ruta al archivo.

```{r}
renabap <- 
  st_read(here("data/raw/renabap/renabap-datos-barrios-gpkg"))
```

#### Visualización interactiva con mapview

La función mapview() permite explorar datos espaciales de forma rápida e interactiva. A continuación se muestran algunos ejemplos con las capas cargadas:

1.  Visualización básica (por defecto):

```{r}
#| echo: true
#| eval: false

mapview(salud_sf)
```

![](images/tp1_01_salud_sf.jpg){width="604"}

2.  Colorear por variable categórica (automático):

```{r}
#| echo: true
#| eval: false
mapview(escuelas, zcol = "sector")
```

3.  Aplicar filtro y personalizar colores por categoría:

```{r}
#| echo: true
#| eval: false
cols_sector <- c("Público" = "steelblue", "Privado" = "orange")


escuelas |>  
  filter(municipio_nombre == 'Ensenada' ) |> 
  mapview(zcol = "sector", 
          layer.name = "Escuelas de Ensenada por sector", 
          col.regions = cols_sector,
          label = 'establecimiento_nombre',
          alpha = 0.5)

mapview(
  escuelas,
  zcol = "sector",
  col.regions = cols_sector,
  layer.name = "Escuelas por sector"
)

```

![](images/tp1_02_escuelas_ensenada.jpg)

4.  Superposición simple de capas:

```{r}
#| echo: true
#| eval: false
mapview(renabap) + mapview(salud_sf)
```

5.  Superposición con estilos personalizados:

```{r}
#| echo: true
#| eval: false
mapview(
  renabap,
  col.regions = "tomato",
  color = "darkred",
  alpha.regions = 0.5,
  layer.name = "Barrios RENABAP"
) +
mapview(
  salud_sf,
  col.regions = "navy",
  layer.name = "Centros de Salud"
)

```

Se debe tener en cuenta que mapview() no se renderiza en documentos PDF, pero sí puede visualizarse en HTML o directamente desde RStudio. Además, al presionar el botón Export en la visualización interactiva, se puede exportar la visualización en HTML.

## Geoprocesos

El **geoprocesamiento vectorial** consiste en aplicar operaciones espaciales sobre datos representados mediante geometrías como puntos, líneas o polígonos. Estas operaciones permiten transformar, combinar y analizar objetos espaciales para generar nueva información o extraer conclusiones útiles en contextos como salud pública, urbanismo, medio ambiente, transporte, entre otros.

El geoprocesamiento vectorial permite:

-   Crear nuevas capas a partir de otras (por ejemplo, zonas de influencia).
-   Analizar relaciones espaciales entre entidades (como qué puntos están dentro de qué polígonos).
-   Extraer atributos espaciales (área, perímetro, centroides, distancias, etc.).
-   Filtrar o recortar geometrías según criterios espaciales.
-   Preparar datos para visualización o modelado.

### Unión espacial con `st_join()`

La función `st_join()` permite realizar una **unión espacial de atributos** entre dos capas vectoriales. Es el equivalente espacial de un "left join" de `dplyr`, pero en lugar de emparejar filas por un valor común, las empareja por su **relación espacial** (como intersección, inclusión, contención, etc.). Esta herramienta es especialmente útil cuando queremos **agregar información de una capa a otra** en función de cómo se relacionan espacialmente.

Sintaxis básica

```{r}
#| eval: false
#| include: false
st_join(x, y, join = st_intersects)
```

**x:** capa principal, que mantiene su geometría.

**y:** capa secundaria, de la que se traen atributos.

**join:** función que define la relación espacial (como st_intersects, st_within, etc.).

El resultado tendrá la geometría de x y los atributos agregados de y, según la relación espacial especificada.

**Tipos de relaciones espaciales usadas en `st_join()`:**

| Relación espacial | Uso dentro de `st_join()` | ¿Qué hace? |
|------------------|------------------|-------------------------------------|
| **Intersección** | `join = st_intersects` | Une atributos si las geometrías se superponen en alguna parte. Muy común para unir puntos dentro de polígonos. |
| **Dentro de** | `join = st_within` | Une solo si la geometría de `x` está completamente dentro de `y`. |
| **Contiene** | `join = st_contains` | Une si `x` contiene completamente a `y`. |
| **Toca** | `join = st_touches` | Une si las geometrías se tocan pero no se superponen. |
| **Cruza** | `join = st_crosses` | Une si las geometrías se cruzan pero no están contenidas entre sí. |
| **Igual** | `join = st_equals` | Une si las geometrías son idénticas. |
| **Cercanía (distancia)** | `join = st_is_within_distance` | Une si los objetos están dentro de una distancia específica. Debe usarse con el argumento adicional `dist = ...`. |

Muchas de estas funciones de relación espacial (`st_intersects`, `st_within`, `st_contains`, etc.) pueden producir resultados similares o incluso iguales en algunos casos, especialmente cuando las geometrías son simples y no se superponen parcialmente.\
Por lo general, se usa `st_intersects` como opción estándar porque captura cualquier tipo de superposición entre geometrías.\
Las otras funciones se emplean en situaciones específicas donde se requiere definir con precisión cómo se relacionan los objetos espaciales (por ejemplo, cuando es importante que una geometría esté completamente dentro de otra, o solo en contacto en el borde). Por eso, la elección de la función depende del objetivo del análisis y del nivel de detalle necesario.

::: callout-warning
Antes de ejecutar un geoproceso entre dos capas es necesario que **ambas estén en el mismo sistema de referencia de coordenadas (CRS)**. Estas se pueden transformar utilizando la función `st_transform()`. Además, si al trabajar con **distancias, áreas, perímetros u otras medidas métricas** es fundamental que el CRS sea **proyectado** (por ejemplo, EPSG:5347), ya que los sistemas geográficos (como WGS84) no ofrecen unidades adecuadas para cálculos precisos.
:::

#### Ejemplo práctico

Queremos identificar qué centros de salud (`salud_sf`) están ubicados dentro de los barrios populares (`renabap`). Para ello, primero es necesario asegurarse de que ambas capas estén en un sistema de coordenadas proyectado (en este caso, `EPSG:5347`), ya que las operaciones espaciales —como la intersección— requieren coherencia en el CRS.


```{r}
renabap <- st_transform(renabap, 5347 )
salud_sf <- st_transform(salud_sf, 5347 )
```

Luego utilizamos st_join() con st_intersects() para realizar la unión espacial. El resultado lo guardamos en un nuevo objeto llamado salud_joined:

```{r}
salud_joined <- 
  st_join(salud_sf,
          renabap,
          join = st_intersects)
head(salud_joined)
```

El objeto resultante, salud_joined, conserva la misma cantidad de filas que el objeto original salud_sf (esto no siempre es así con st_intersects, como veremos más adelante). A sus atributos se le suman las columnas provenientes de renabap, en aquellos casos donde existe una intersección espacial.

En las filas donde no hay intersección entre el centro de salud y algún barrio popular, las columnas correspondientes a renabap tendrán valores vacíos (NA). 

Probemos ahora a hacer la union espacial pero colocanco como primer argumento (x) a la capa renabap:

```{r}

renabap_joined <- 
  st_join(renabap,
          salud_sf,
          join = st_intersects)
head(renabap_joined)
```

Observese que mientras el objeto original renabap antes del join tiene `r nrow(renabap)` filas, luego de hacer el join pasa a tener `r nrow(renabap_joined)` filas. ¿De donde surgen estas `r nrow(renabap_joined) - nrow(renabap) ` filas de diferencia? 

La respuesta es que existen barrios populares con más de un centro de salud en su interior. En otras palabras, cuando un mismo barrio intersecta con más de un centro de salud, el resultado del st_join() devuelve una fila por cada combinación de barrio y centro de salud intersectante, generando así múltiples registros para un mismo barrio.

```{r}
renabap_joined |>
  st_drop_geometry() |>
  count(id_renabap, nombre_barrio, name = 'cantidad_centros_salud') |>
  filter(cantidad_centros_salud > 1)
```


### Otros geoprocesos vectoriales comunes

Además de `st_join()`, existen varias funciones en `sf` que resultan fundamentales para el análisis espacial y la manipulación de datos vectoriales. Estas herramientas permiten trabajar con las geometrías y atributos de manera eficiente para responder a diferentes preguntas geográficas.

| Función | ¿Qué hace? | Ejemplo básico |
|-------------|---------------------------------------------|-------------|
| `st_filter()` | Filtra objetos de una capa en función de su relación espacial con otra capa. No agrega atributos, solo selecciona. | `st_filter(puntos, poligono, .predicate = st_within)` |
| `st_buffer()` | Genera un área de influencia o zona de proximidad alrededor de una geometría. Muy útil para analizar cobertura o impacto. | `st_buffer(salud_sf, dist = 500)` |
| `st_intersection()` | Devuelve la geometría que resulta de la superposición espacial entre dos capas. | `st_intersection(capa1, capa2)` |
| `st_union()` | Une múltiples geometrías en una sola, útil para agrupar o simplificar capas. | `st_union(capa)` |
| `st_difference()` | Calcula la diferencia entre dos geometrías, eliminando la parte común. | `st_difference(capa1, capa2)` |
| `st_centroid()` | Calcula el centro geométrico de cada objeto. Útil para representar polígonos como puntos. | `st_centroid(poligonos)` |
| `st_distance()` | Calcula la distancia mínima entre geometrías. Fundamental para análisis de cercanía. | `st_distance(puntos1, puntos2)` |
| `st_area()` | Calcula el área de polígonos. Requiere un CRS proyectado para obtener resultados en m². | `st_area(poligonos)` |

------------------------------------------------------------------------

------------------------------------------------------------------------






```{r}
sf::sf_use_s2(FALSE)
```



Si solo quiero saber que geometrías están dentro de otra uso st_filter()

```{r}
st_filter(salud_sf,
          renabap,
          join = st_intersects)

```

```{r}
ggplot() +
  geom_sf(data = renabap, fill = "tomato", color = "darkred", alpha = 0.5) +
  labs(title = "Barrios Populares (RENABAP)",
       subtitle = "Fuente: datos.gob.ar",
       caption = "Visualización con geom_sf()")+
  theme_minimal()

```

```{r}
renabap_pba <- 
  renabap %>% filter(provincia == 'Buenos Aires')
```

```{r}
ggplot() +
  geom_sf(data = renabap_pba, fill = "tomato", color = "darkred", alpha = 0.5) +
  labs(title = "Barrios Populares (RENABAP)",
       subtitle = "Fuente: datos.gob.ar",
       caption = "Visualización con geom_sf()")+
  theme_minimal()
```
