---
title: "Sistemas de información geográfica. TP2: Geoprocesos con datos vectoriales (continuación)."
author: Marcos May
email: mmmay@fahce.unlp.edu.ar
format:
  pdf:
    toc: true
    toc-title: Indice
    number-sections: false
    toc-depth: 3
editor_options: 
  chunk_output_type: inline
---

## Objetivos

Este trabajo se propone introducir herramientas de análisis geoespacial con R aplicadas a una problemática educativa territorial: **la accesibilidad a escuelas secundarias** y las condiciones socioeducativas del entorno.

El ejercicio se desarrolla en el partido de **La Plata**, y se trabajará exclusivamente con **datos geográficos vectoriales**, es decir, información representada como **puntos** (escuelas) y **polígonos** (radios censales), incorporando atributos provenientes del **Censo 2022**.

------------------------------------------------------------------------

intro
tp1: geoprocesos presentacion
tp2: indice de accesibilidad

tp3: matriz de distancia, buffer de distancia fija, intersection,st_area, st_union

tp4: uso de apis: mapbox (uso de distancia manhatann, isocronas); georref; osmdata();

tp5: imagenes raster: carga; visualizacvion; principios basicos; extract; ejemplo: volumen construído

```{r setup, warning=FALSE, echo=FALSE, message=FALSE}
library(tidyverse)   # Manipulación de datos  
library(sf)          # Datos espaciales  
library(mapview)     # Mapas interactivos  
library(units)       # Manejo de distancias (metros/km)  
library(nngeo)       # Para cálculos de distancia más cercana  
library(here)        # Para manejar el path
library(janitor)     # Para limpieza de datos
library(ggspatial)
library(maptiles)
library(prettymapr)
library(readxl)
```


```{r}
rm(list = ls())
load(here('data/processed/lp.Rda'))
#load(here('data/processed/secundarias_lp.Rda'))
```

```{r}
salud <- st_read(here('data/processed/salud/centros_de_salud.gpkg'))
```
Cargamos el excel que descargamos de INDEC con la cantidad de hogares con algún porcentaje de nbi en los radios de La Plata

```{r}
nbi <- 
  read_excel(here("data/processed/redatam_censo/la_plata_nbi_radio.xlsX"),
             skip = 11,
             n_max = 1048) |> 
  rename(con_nbi = Sí,
         sin_nbi = No) |> 
  select(Código, con_nbi)
```

```{r}
lp <- left_join(lp,
                nbi,
                by = c('codigo' = 'Código'))
```


```{r}
glimpse(salud)
```


```{r}
salud <-  st_transform(salud, st_crs(lp))
salud <- st_filter(salud,lp)


```


los caps son las salitas municipales, quiero ver esos

```{r}
salitas <- salud |> filter(tes == 'Municipal')
```


```{r}
buffer <- salitas |> st_buffer(dist = 500)
```

Hago un join espacial, teniendo en cuenta la diferencia entre st_join() y st_intersection()

```{r}
lp_join <- st_join(buffer,
                   lp,
                   join = st_intersects)
```

```{r}
lp_join_ <- 
  lp_join |> 
  group_by(id) |> 
  summarise(nbi = sum(con_nbi) / sum(total_hogares), .groups = 'drop')
```

```{r}

```





```{r}
lp_intersection <- st_intersection (buffer,lp)
```


```{r}
lp$area <- as.numeric(st_area(lp))
```

```{r}
lp_intersection <- 
  st_intersection (lp,buffer)

```
```{r}
lp_intersection$area_i <- as.numeric(st_area(lp_intersection))
```

```{r}
lp_intersection <- 
  lp_intersection |> 
  mutate(prop_interseccion = area_i / area )
```


```{r}
summary(lp_intersection$prop_interseccion)
lp_intersection$area_km2 = factor( lp_intersection$area / 1000000)

```

```{r}
mapview(lp_intersection, 
        zcol = 'prop_interseccion',
        label = 'area_km2')
```
mapa coroplético
en mapview controlo color.region y quiebres con at. el valor central es el quiebre, mapa binario

```{r}
library(classInt)

breaks_jenks <- classInt::classIntervals(lp_intersection$prop_interseccion,
                                         n = 5, 
                                         style = "jenks")
cortes <- breaks_jenks$brks

colores <- colorRampPalette(colors = c("white", "red"))

mapview(lp_intersection,
        zcol = "prop_interseccion",
        layer.name = "Proporción de intersección",
        col.regions = colores,
        at = c(0, 0.33, 1), 
        legend = TRUE)

```

```{r}
 mapview(lp_intersection,
         zcol = "prop_interseccion",
         at = c(0, 0.30, 1),
         layer.name = "Proporción de intersección",
         legend = TRUE)
```
 
Lor sadios en blanco serán descarods.


```{r}
lp_intersection <- 
  lp_intersection |> filter(prop_interseccion > 0.333)
```


controlo con do_union dentro de summarise para fusionar o no las geometrías agrupadas
```{r}
salitas <- 
  lp_intersection |> 
  group_by(id) |> 
  summarise(nbi_per = sum(con_nbi) / sum(total_hogares),
            .groups = 'drop',  
            do_union = TRUE) |>  #poner FALSE para mantener separadas las geometrias 
  st_drop_geometry() |> 
  right_join(salitas)

```

```{r}
p <- lp_intersection |> 
  group_by(id) |> 
  mutate(nbi_per = sum(con_nbi) / sum(total_hogares)) |> 
  ungroup() |> 
  st_drop_geometry() |> 
  select(id,area_km2, prop_interseccion) |> arrange(desc(area_km2))


  
```






2


una api es una interfaz que permite el intercambio de datos entre sistemas informpáticos: el servidor te da datos específicos sin tener toda la base
